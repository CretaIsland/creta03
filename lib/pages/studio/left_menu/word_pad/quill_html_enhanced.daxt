import 'dart:async';

import 'package:creta03/design_system/buttons/creta_button.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:html_editor_enhanced/html_editor.dart';
import 'package:file_picker/file_picker.dart';
import '../../../../design_system/buttons/creta_button_wrapper.dart';
import '../../../../design_system/creta_color.dart';
import '../../../../model/app_enums.dart';
import '../../../../model/contents_model.dart';
import '../../studio_variables.dart';

class QuillHtmlEnhanced extends StatefulWidget {
  final ContentsModel document;
  final Color bgColor;
  final Size size;
  const QuillHtmlEnhanced(
      {super.key, required this.document, required this.size, required this.bgColor});
  @override
  State<QuillHtmlEnhanced> createState() => _QuillHtmlEnhancedState();
}

class _QuillHtmlEnhancedState extends State<QuillHtmlEnhanced> with TickerProviderStateMixin {
  String result = '';
  HtmlEditorController? _currentController;
  bool _isEditorFocused = true;

  final GlobalObjectKey _toolbarKey = const GlobalObjectKey('ToolbarWidgetonQuillEditor');

  late final AnimationController _controller =
      AnimationController(duration: const Duration(milliseconds: 250), vsync: this);

  // late final Animation<double> _animation =
  //     CurvedAnimation(parent: _controller, curve: Curves.fastOutSlowIn);

  @override
  void initState() {
    super.initState();
    _currentController = HtmlEditorController();
  }

  @override
  Widget build(BuildContext context) {
    if (_currentController != null) {
      _controller.animateTo(1, duration: const Duration(milliseconds: 100));
    }

    return Scaffold(
      appBar: AppBar(backgroundColor: CretaColor.primary, toolbarHeight: 30.0),
      body: SingleChildScrollView(
        child: Stack(
          alignment: Alignment.topCenter,
          children: <Widget>[
            Container(
              // margin: _isEditorFocused ? const EdgeInsets.only(top: 16.0) : null,
              padding: _isEditorFocused && StudioVariables.isPreview == false
                  ? const EdgeInsets.only(top: 132.0, left: 28.0)
                  : null,
              width: widget.size.width,
              height: widget.size.height,
              color: widget.bgColor,
              child: _htmlEditor(),
            ),
            if (_isEditorFocused == true && StudioVariables.isPreview == false) _popupToolBox(),
          ],
        ),
      ),
    );
  }

  Widget _htmlEditor() {
    return HtmlEditor(
      controller: _currentController!,
      htmlEditorOptions: HtmlEditorOptions(
        // hint: widget.document.remoteUrl,
        //disabled: true,
        initialText: widget.document.remoteUrl,
        shouldEnsureVisible: true,
        autoAdjustHeight: false,
      ),
      htmlToolbarOptions: const HtmlToolbarOptions(
        toolbarPosition: ToolbarPosition.custom,
      ),
      otherOptions: const OtherOptions(height: 900),
      callbacks: Callbacks(onBeforeCommand: (String? currentHtml) {
        debugPrint('html before change is $currentHtml');
      }, onChangeContent: (String? changed) {
        debugPrint('content changed to $changed');
        widget.document.remoteUrl = changed;
        widget.document.filter.set(widget.document.filter.value == ImageFilterType.bright
            ? ImageFilterType.cold
            : ImageFilterType.bright);
        debugPrint('onCompletedText is:  ${widget.document.remoteUrl}');
      }, onEnter: () {
        debugPrint('enter/return pressed');
      }, onFocus: () {
        debugPrint('editor focused');
        setState(() {
          _isEditorFocused = true;
          resetTimeout();
        });
      }, onBlur: () {
        debugPrint('editor unfocused');
      }, onInit: () {
        debugPrint('init');
      }),
    );
  }

  Widget foldingButton() {
    return (_isEditorFocused == true && StudioVariables.isPreview == false)
        ? InkWell(
            child: Container(
              width: 32.0,
              height: 24.0,
              decoration: BoxDecoration(
                color: CretaColor.primary[200],
                borderRadius: const BorderRadius.only(
                  bottomLeft: Radius.circular(32.0),
                  bottomRight: Radius.circular(32.0),
                ),
              ),
              child: BTN.fill_gray_i_m(
                icon: Icons.keyboard_double_arrow_up,
                buttonColor: CretaButtonColor.transparent,
                onPressed: () {
                  debugPrint('-------Hidden button pressed-------');
                  setState(() {
                    setTimeout();
                    _isEditorFocused = false;
                  });
                },
              ),
            ),
            //),
          )
        : const SizedBox.shrink();
  }

  // ignore: unused_element
  Widget _popupToolBox() {
    return _currentController == null
        ? const SizedBox.shrink()
        : Container(
            width: widget.size.width,
            decoration: BoxDecoration(color: CretaColor.primary[200]),
            child: Padding(
              padding: const EdgeInsets.all(4.0),
              child: StudioVariables.isPreview == false
                  ? ToolbarWidget(
                      key: _toolbarKey,
                      controller: _currentController!,
                      foldingButton: foldingButton(),
                      callbacks: Callbacks(
                        onHiddenToolbar: () {
                          debugPrint('-------- Close btn pressed-------------');
                          setState(() {
                            setTimeout();
                            _isEditorFocused = false;
                          });
                        },
                      ),
                      htmlToolbarOptions: HtmlToolbarOptions(
                        toolbarPosition: ToolbarPosition.custom,
                        toolbarType: ToolbarType.nativeGrid,
                        onButtonPressed: (ButtonType type, bool? status, Function? updateStatus) {
                          debugPrint(
                              "button '${describeEnum(type)}' pressed, the current selected status is $status");
                          return true;
                        },
                        mediaLinkInsertInterceptor: (String url, InsertFileType type) {
                          // debugPrint(url);
                          return true;
                        },
                        mediaUploadInterceptor: (PlatformFile file, InsertFileType type) async {
                          return true;
                        },
                      ),
                    )
                  : const SizedBox.shrink(),
            ),
          );
  }

  Timer? timer;

  void resetTimeout() {
    timer?.cancel();
    timer = null;
  }

  void setTimeout() {
    timer = Timer(const Duration(milliseconds: 100), () {
      if (_currentController != null) {
        _controller.reverse(from: 1).then((_) {
          if (mounted) {}
        });
      }
    });
  }
}
